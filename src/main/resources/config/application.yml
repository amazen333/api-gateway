# ============================================
# API Gateway Configuration - Spring Cloud 2024.0.0
# Java 17+ / Spring Boot 3.4.0 compatible
# ============================================

server:
  port: ${SERVER_PORT:8080}
  shutdown: graceful
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json,application/xml,application/wasm
    min-response-size: 1024
  max-http-request-header-size: 16KB
  netty:
    connection-timeout: 2s
    idle-timeout: 30s

spring:
  application:
    name: ${SPRING_APPLICATION_NAME:snmp-gateway}

  config:
    import: "optional:configserver:"
    activate:
      on-cloud-platform: kubernetes
  main:
    web-application-type: reactive
    banner-mode: off
    allow-circular-references: false
    allow-bean-definition-overriding: false

  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      username: ${REDIS_USERNAME:}
      password: ${REDIS_PASSWORD:}
      client-type: lettuce
      connect-timeout: 2s
      timeout: 1s
      ssl:
        enabled: ${REDIS_SSL_ENABLED:false}
      lettuce:
        pool:
          enabled: true
          max-active: 16
          max-idle: 8
          min-idle: 4
          max-wait: 2s
          time-between-eviction-runs: 5s
        shutdown-timeout: 100ms
        cluster:
          refresh:
            adaptive: true
            period: 30s
            dynamic-refresh-sources: true

  cloud:
    # =============== EUREKA CONFIGURATION ===============
    discovery:
      client:
        simple:
          instances:
            auth-service:
              - uri: ${AUTH_SERVICE_URL:http://localhost:8081}
            device-service:
              - uri: ${DEVICE_SERVICE_URL:http://localhost:8082}
        # For Spring Cloud 2024.0.0+, you can use either:
        # Option 1: Spring Cloud LoadBalancer (recommended for new projects)
        # Option 2: Eureka (if you have existing Eureka infrastructure)
        # 
        # Uncomment the one you want to use:
        
        # === OPTION 1: Spring Cloud LoadBalancer (Default) ===
        enabled: true
        health-check:
          enabled: true
        health-indicator:
          enabled: true
        
        # === OPTION 2: Eureka Client ===
        # eureka:
        #   enabled: ${EUREKA_ENABLED:true}
        #   instance:
        #     hostname: ${EUREKA_INSTANCE_HOSTNAME:${spring.application.name}}
        #     prefer-ip-address: ${EUREKA_PREFER_IP_ADDRESS:false}
        #     lease-renewal-interval-in-seconds: ${EUREKA_LEASE_RENEWAL_INTERVAL:30}
        #     lease-expiration-duration-in-seconds: ${EUREKA_LEASE_EXPIRATION_DURATION:90}
        #     metadata-map:
        #       zone: ${EUREKA_ZONE:default}
        #       version: ${APP_VERSION:1.0.0}
        #     health-check-url-path: ${MANAGEMENT_ENDPOINTS_WEB_BASE_PATH:/admin}/health
        #     status-page-url-path: ${MANAGEMENT_ENDPOINTS_WEB_BASE_PATH:/admin}/info
        #   client:
        #     enabled: ${EUREKA_CLIENT_ENABLED:true}
        #     register-with-eureka: ${EUREKA_REGISTER_WITH_EUREKA:true}
        #     fetch-registry: ${EUREKA_FETCH_REGISTRY:true}
        #     service-url:
        #       defaultZone: ${EUREKA_SERVICE_URL:http://localhost:8761/eureka/}
        #     registry-fetch-interval-seconds: ${EUREKA_REGISTRY_FETCH_INTERVAL:30}
        #     disable-delta: ${EUREKA_DISABLE_DELTA:false}
        #     healthcheck:
        #       enabled: ${EUREKA_HEALTHCHECK_ENABLED:true}
    
    # =============== LOAD BALANCER CONFIGURATION ===============
    loadbalancer:
      retry:
        enabled: true
        max-retries-on-next-service-instance: 1
        max-retries-on-same-service-instance: 0
      cache:
        enabled: true
        ttl: 30s
        capacity: 1000
      zones:
        - name: default
          instances: all
      health-check:
        interval: 30s
        path: ${MANAGEMENT_ENDPOINTS_WEB_BASE_PATH:/admin}/health
    
    # =============== CIRCUIT BREAKER CONFIGURATION ===============
    circuitbreaker:
      resilience4j:
        enabled: true
        configs:
          default:
            slidingWindowSize: 20
            failureRateThreshold: 50
            waitDurationInOpenState: 10s
            permittedNumberOfCallsInHalfOpenState: 5
            automaticTransitionFromOpenToHalfOpenEnabled: true
            slowCallRateThreshold: 100
            slowCallDurationThreshold: 2s
            record-exceptions:
              - org.springframework.web.reactive.function.client.WebClientRequestException
              - java.io.IOException
              - java.util.concurrent.TimeoutException
              - org.springframework.cloud.gateway.support.NotFoundException
            ignore-exceptions:
              - com.iotplatform.gateway.exceptions.BusinessException
        
        instances:
          authService:
            baseConfig: default
            failureRateThreshold: 30
            waitDurationInOpenState: 5s
          deviceService:
            baseConfig: default
            failureRateThreshold: 40
          adminService:
            baseConfig: default
            slidingWindowSize: 10
            failureRateThreshold: 20
            waitDurationInOpenState: 30s
    
    # =============== GATEWAY CONFIGURATION ===============
    gateway:
      metrics:
        enabled: true
        tags:
          path: true
          method: true
          status: true
          outcome: true
          exception: true
          service: true
          instance: true
      
      httpclient:
        connect-timeout: 2
        response-timeout: 10s
        pool:
          type: elastic
          max-connections: 1000
          max-idle-time: 30s
        proxy:
          host: ${HTTP_PROXY_HOST:}
          port: ${HTTP_PROXY_PORT:}
        ssl:
          handshake-timeout: 10s
          close-notify-flush-timeout: 3s
          close-notify-read-timeout: 0s
      
      default-filters:
        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin
        - name: CircuitBreaker
          args:
            name: defaultCircuitBreaker
            fallbackUri: forward:/fallback/default
        - name: RequestHeaderSize
          args:
            maxSize: 16KB
        - name: SetResponseHeader
          args:
            name: X-Content-Type-Options
            value: nosniff
        - name: SetResponseHeader
          args:
            name: X-Frame-Options
            value: DENY
        - name: SetResponseHeader
          args:
            name: X-XSS-Protection
            value: 0
        - name: SetResponseHeader
          args:
            name: Cache-Control
            value: "no-cache, no-store, max-age=0, must-revalidate"
        - name: SetResponseHeader
          args:
            name: Pragma
            value: no-cache
        - name: SetResponseHeader
          args:
            name: Expires
            value: "0"
        - name: SetResponseHeader
          args:
            name: Server
            value: "IoT-Platform-Gateway"
        - name: SetResponseHeader
          args:
            name: X-Gateway-Version
            value: ${APP_VERSION:1.0.0}
      
      routes:
        - id: auth_service
          uri: ${AUTH_SERVICE_URI:lb://auth-service}
          predicates:
            - Path=/api/v1/auth/**,/api/v1/oauth2/**
            - Method=GET,POST,PUT,DELETE,PATCH
          filters:
            - name: CircuitBreaker
              args:
                name: authService
                fallbackUri: forward:/fallback/auth
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 50
                redis-rate-limiter.burstCapacity: 100
                redis-rate-limiter.requestedTokens: 1
                key-resolver: "#{@userKeyResolver}"
            - name: TokenRelay
            - SetResponseHeader=X-Service-Name, auth-service
        
        - id: device_service
          uri: ${DEVICE_SERVICE_URI:lb://device-service}
          predicates:
            - Path=/api/v1/devices/**,/api/v1/sensors/**
            - Method=GET,POST,PUT,DELETE,PATCH
          filters:
            - name: CircuitBreaker
              args:
                name: deviceService
                fallbackUri: forward:/fallback/device
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 100
                redis-rate-limiter.burstCapacity: 200
                redis-rate-limiter.requestedTokens: 1
                key-resolver: "#{@apiKeyResolver}"
            - SetResponseHeader=X-Service-Name, device-service
        
        - id: open_api_docs
          uri: ${GATEWAY_URI:http://localhost:${server.port}}
          predicates:
            - Path=/v3/api-docs/**,/swagger-ui/**,/swagger-ui.html,/webjars/**
          filters:
            - RewritePath=/v3/api-docs/(?<path>.*), /$\{path}/v3/api-docs
        
        - id: websocket_route
          uri: ${WEBSOCKET_SERVICE_URI:lb:ws://device-service}
          predicates:
            - Path=/ws/**,/topic/**
          filters:
            - StripPrefix=1
        
        - id: static_resources
          uri: ${STATIC_RESOURCES_URI:classpath:/static/}
          predicates:
            - Path=/static/**,/favicon.ico,/robots.txt
          filters:
            - SetResponseHeader=Cache-Control, "public, max-age=3600"
        
        # =============== ADMIN ROUTES WITH RATE LIMITING ===============
        - id: admin_service
          uri: ${ADMIN_SERVICE_URI:lb://admin-service}
          predicates:
            - Path=/api/v1/admin/**
            - Method=GET,POST,PUT,DELETE,PATCH
          filters:
            - name: CircuitBreaker
              args:
                name: adminService
                fallbackUri: forward:/fallback/admin
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 5
                redis-rate-limiter.burstCapacity: 10
                redis-rate-limiter.requestedTokens: 1
                key-resolver: "#{@ipKeyResolver}"
            - SetResponseHeader=X-Service-Name, admin-service
        
        # =============== METRICS SERVICE ===============
        - id: metrics_service
          uri: ${METRICS_SERVICE_URI:lb://metrics-service}
          predicates:
            - Path=/api/v1/metrics/**,/api/v1/telemetry/**
          filters:
            - name: CircuitBreaker
              args:
                name: metricsService
                fallbackUri: forward:/fallback/metrics
            - StripPrefix=2
            - SetResponseHeader=X-Service-Name, metrics-service

  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${JWT_ISSUER_URI:http://localhost:8081/realms/iot-platform}
          jwk-set-uri: ${JWT_JWK_SET_URI:http://localhost:8081/realms/iot-platform/protocol/openid-connect/certs}
          audiences: ${JWT_AUDIENCES:iot-platform-api}

# =============== MANAGEMENT ENDPOINTS ===============
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,circuitbreakers,loggers,caches,gateway
      base-path: /admin
      path-mapping:
        health: healthcheck
    access:
      default: read-only
  endpoint:
    health:
      access: read-only
      show-components: always
      probes:
        enabled: true
      group:
        readiness:
          include: redis,discoveryClient,diskSpace,ping,custom
        liveness:
          include: ping,custom
    metrics:
      access: read-only
    gateway:
      access: read-only
    prometheus:
      access: read-only
  prometheus:
    metrics:
      export:
        enabled: true
        step: 1m
        descriptions: true
  metrics:
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:development}
    distribution:
      percentiles-histogram:
        http.server.requests: true
      sla:
        http.server.requests: 100ms,500ms,1s,2s

# =============== EUREKA SPECIFIC PROPERTIES ===============
# Uncomment and configure if using Eureka instead of Spring Cloud LoadBalancer
# eureka:
#   client:
#     enabled: ${EUREKA_ENABLED:true}
#     service-url:
#       defaultZone: ${EUREKA_SERVICE_URL:http://localhost:8761/eureka/}
#     healthcheck:
#       enabled: ${EUREKA_HEALTHCHECK_ENABLED:true}
#     registry-fetch-interval-seconds: ${EUREKA_REGISTRY_FETCH_INTERVAL:30}
#     instance-info-replication-interval-seconds: 30
#     initial-instance-info-replication-interval-seconds: 40
#   instance:
#     hostname: ${EUREKA_INSTANCE_HOSTNAME:localhost}
#     appname: ${spring.application.name}
#     instanceId: ${spring.application.name}:${server.port}
#     lease-renewal-interval-in-seconds: ${EUREKA_LEASE_RENEWAL_INTERVAL:30}
#     lease-expiration-duration-in-seconds: ${EUREKA_LEASE_EXPIRATION_DURATION:90}
#     prefer-ip-address: ${EUREKA_PREFER_IP_ADDRESS:false}
#     ip-address: ${EUREKA_IP_ADDRESS:}
#     non-secure-port: ${server.port}
#     secure-port-enabled: false
#     metadata-map:
#       zone: ${EUREKA_ZONE:default}
#       profile: ${spring.profiles.active:default}
#       version: ${APP_VERSION:1.0.0}

# =============== RATE LIMITING CONFIGURATION ===============
spring.cloud.gateway.filter.request-rate-limiter.redis-rate-limiter:
  replenishRate: ${RATE_LIMIT_REPLENISH_RATE:10}
  burstCapacity: ${RATE_LIMIT_BURST_CAPACITY:20}
  requestedTokens: ${RATE_LIMIT_REQUESTED_TOKENS:1}

# =============== LOGGING CONFIGURATION ===============
logging:
  level:
    root: ${ROOT_LOG_LEVEL:INFO}
    com.iotplatform.gateway: ${APP_LOG_LEVEL:DEBUG}
    org.springframework.cloud.gateway: ${GATEWAY_LOG_LEVEL:DEBUG}
    org.springframework.security: ${SECURITY_LOG_LEVEL:INFO}
    reactor.netty: ${NETTY_LOG_LEVEL:INFO}
    io.github.resilience4j: ${RESILIENCE4J_LOG_LEVEL:INFO}
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/${spring.application.name}.log
    max-size: 10MB
    max-history: 30
    total-size-cap: 100MB

# =============== APPLICATION-SPECIFIC PROPERTIES ===============
app:
  gateway:
    cors:
      allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:4200,http://localhost:3000}
      allowed-methods: GET,POST,PUT,DELETE,PATCH,OPTIONS
      allowed-headers: "*"
      allow-credentials: true
      max-age: 3600
    security:
      jwt:
        secret: ${JWT_SECRET:your-256-bit-secret-key-for-jwt-signing-and-validation-2024}
        expiration: ${JWT_EXPIRATION:86400000}
      api-key:
        header-name: X-API-Key
        valid-keys: ${API_VALID_KEYS:test-key-123,prod-key-456}
    cache:
      enabled: true
      ttl-seconds: 300
      max-size: 1000

# =============== PROFILES ===============
---
spring:
  config:
    activate:
      on-profile: docker

eureka:
  client:
    enabled: ${EUREKA_ENABLED:true}
    service-url:
      defaultZone: ${EUREKA_SERVICE_URL:http://eureka-server:8761/eureka/}
  instance:
    hostname: ${HOSTNAME:api-gateway}
    prefer-ip-address: true

spring.data.redis.host: ${REDIS_HOST:redis}
---
spring:
  config:
    activate:
      on-profile: kubernetes

eureka:
  client:
    enabled: false  # Use Kubernetes service discovery instead


  cloud:
    kubernetes:
      discovery:
        enabled: true
        all-namespaces: false
        primary-port-name: http
      loadbalancer:
        enabled: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: always
---
spring:
  config:
    activate:
      on-profile: local-dev

eureka:
  client:
    enabled: true
    service-url:
      defaultZone: http://localhost:8761/eureka/

logging:
  level:
    com.iotplatform.gateway: TRACE
    org.springframework.cloud.gateway: DEBUG